# Geospatial data II: Vector-raster integration

## Lecture summary 

This week we will learn how to crop a raster using the extent of a vector layer. We will also cover how to extract values from a raster that occur within a set of polygons, or in a buffer (surrounding) region around a set of points. We will also import spatial points stored in `.csv` (Comma Separated Value) format into R as an `sf` spatial object. Lastly, we will reproject data imported from an ESRI `shapefile` format, export the reprojected  data as an ESRI `shapefile`, and plot raster and vector data as layers in the same plot. The reading is about R's debugging tools and in the lab we will create a spatial points layer for the bee occurences, and overlay bioregion vector data. These demos are based on Software Carpentery's spatial data lessons. 

###   Learning Objectives

For Monday, we will: 

- Use the `crop()` function to crop a raster object.
- Use the `extract()` function to extract pixels from a raster object that fall
  within a particular extent boundary.
- Use the `ext()` function to define an extent.

For Wednesday, we will;

- Import .csv files containing x,y coordinate locations into R as a data frame.
- Convert a data frame to a spatial object.
- Export a spatial object to a text file.

```{r setup, echo=FALSE}
source("src/setup.R")
```
```{r load-libraries, echo=FALSE, results="hide", message=FALSE, warning=FALSE}
library(sf)
library(terra)
library(ggplot2)
library(dplyr)
```


Here's a visualization of the types of data we are using (same as last week). 

![](fig/lidarTree-height.png){alt='DTM vs DSM vs CHM'}

First let's load the data. 

```{r load-data, echo=FALSE, results="hide"}
# We loaded most of this data last week, + a few extras

## data collection tower locations
point_HARV <-
  st_read("data/NEON-DS-Site-Layout-Files/HARV/HARVtower_UTM18N.shp")
## roads
lines_HARV <-
  st_read("data/NEON-DS-Site-Layout-Files/HARV/HARV_roads.shp")
## area of interest boundary (study area boundary)
aoi_boundary_HARV <-
  st_read("data/NEON-DS-Site-Layout-Files/HARV/HarClip_UTMZ18.shp")

# CHM (canopy height model)
CHM_HARV <-
  rast("data/NEON-DS-Airborne-Remote-Sensing/HARV/CHM/HARV_chmCrop.tif")
CHM_HARV_df <- as.data.frame(CHM_HARV, xy = TRUE)

# plot locations (CSV)
plot_locations_HARV <-
  read.csv("data/NEON-DS-Site-Layout-Files/HARV/HARV_PlotLocations.csv")
utm18nCRS <- st_crs(point_HARV)
plot_locations_sp_HARV <- st_as_sf(plot_locations_HARV,
                                   coords = c("easting", "northing"),
                                   crs = utm18nCRS)
# plot locations (vector data)
plots_HARV <-
  st_read("data/NEON-DS-Site-Layout-Files/HARV/PlotLocations_HARV.shp")

## new, us states
country_boundary_US <- st_read("data/NEON-DS-Site-Layout-Files/US-Boundary-Layers/US-Boundary-Dissolved-States.shp")
## data collection towers
```

**Part 1: Crop a Raster to Vector Extent**

We often work with spatial layers that have different spatial extents (illustration of extents as a reminder below). The spatial extent of a vector layer or R spatial object represents the geographic
"edge" or location that is the furthest north, south east and west. Thus it represents the overall geographic coverage of the spatial object.

![](fig/dc-spatial-vector/spatial_extent.png){alt='Extent illustration'} Image Source: National
Ecological Observatory Network (NEON)

The graphic below illustrates the extent of several of the spatial layers that
we have worked with last week + some new data:

- Area of interest (AOI) -- blue
- Roads and trails -- purple
- Vegetation plot locations (marked with white dots)-- black
- A canopy height model (CHM) in GeoTIFF format -- green


CHM is a raster, but we want it as a vector layer, so we can convert it using the function `st_as_sf`. 

```{r view-extents, echo=FALSE, results="hide"}

# create CHM as a vector layer
CHM_HARV_sp <- st_as_sf(CHM_HARV_df, coords = c("x", "y"), crs = utm18nCRS)

# approximate the boundary box with a random sample of raster points
CHM_rand_sample <- sample_n(CHM_HARV_sp, 10000)

```

Now we can visualize all of our datasets.

```{r compare-data-extents, echo=FALSE}

ggplot() +
  geom_sf(data = st_convex_hull(st_union(CHM_rand_sample)), fill = "green") +
  geom_sf(data = st_convex_hull(st_union(lines_HARV)),
          fill = "purple", alpha =  0.2) +
  geom_sf(data = lines_HARV, aes(color = TYPE), size = 1) +
  geom_sf(data = aoi_boundary_HARV, fill = "blue") +
  geom_sf(data = st_convex_hull(st_union(plot_locations_sp_HARV)),
          fill = "black", alpha = 0.4) +
  geom_sf(data = plots_HARV, color = "white") +
  theme(legend.position = "none") 

```
You can see the CHM raster is much larger than our areas of interest. 

Frequent use cases of cropping a raster file include reducing file size and
creating maps. Sometimes we have a raster file that is much larger than our
study area or area of interest (as we have now). It is often more efficient to crop the raster
to the extent of our study area to reduce file sizes as we process our data.
Cropping a raster can also be useful when creating pretty maps so that the
raster layer matches the extent of the desired vector layers.

**Crop a Raster Using Vector Extent**

We can use the `crop()` function to crop a raster to the extent of another
spatial object. To do this, we need to specify the raster to be cropped and the
spatial object that will be used to crop the raster. R will use the `extent` of
the spatial object as the cropping boundary.

To illustrate this, we will crop the Canopy Height Model (CHM) to only include
the area of interest (AOI). Let's start by plotting the full extent of the CHM
data and overlay where the AOI falls within it. The boundaries of the AOI will
be colored blue, and we use `fill = NA` to make the area transparent.

```{r crop-by-vector-extent}
ggplot() +
  geom_raster(data = CHM_HARV_df, aes(x = x, y = y, fill = HARV_chmCrop)) +
  scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) +
  geom_sf(data = aoi_boundary_HARV, color = "blue", fill = NA)
```

Now that we have visualized the area of the CHM we want to subset, we can
perform the cropping operation. We are going to `crop()` function from the
raster package to create a new object with only the portion of the CHM data
that falls within the boundaries of the AOI.

```{r}
CHM_HARV_Cropped <- crop(x = CHM_HARV, y = aoi_boundary_HARV)
```

Now we can plot the cropped CHM data, along with a boundary box showing the
full CHM extent. However, remember, since this is raster data, we need to
convert to a data frame in order to plot using `ggplot`. To get the boundary
box from CHM, the `st_bbox()` will extract the 4 corners of the rectangle that
encompass all the features contained in this object. The `st_as_sfc()` converts
these 4 coordinates into a polygon that we can plot:

```{r show-cropped-area}
CHM_HARV_Cropped_df <- as.data.frame(CHM_HARV_Cropped, xy = TRUE)

ggplot() +
  geom_sf(data = st_as_sfc(st_bbox(CHM_HARV)), fill = "green",
          color = "green", alpha = .2) +
  geom_raster(data = CHM_HARV_Cropped_df,
              aes(x = x, y = y, fill = HARV_chmCrop)) +
  scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) 
```

The plot above shows that the full CHM extent (plotted in green) is much larger
than the resulting cropped raster. Our new cropped CHM now has the same extent
as the `aoi_boundary_HARV` object that was used as a crop extent (blue border
below).

```{r view-crop-extent}
ggplot() +
  geom_raster(data = CHM_HARV_Cropped_df,
              aes(x = x, y = y, fill = HARV_chmCrop)) +
  geom_sf(data = aoi_boundary_HARV, color = "blue", fill = NA) +
  scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) +
  coord_sf()
```

We can look at the extent of all of our other objects for this field site.

```{r view-extent}
ext(CHM_HARV)
ext(CHM_HARV_Cropped)
ext(aoi_boundary_HARV)
ext(plot_locations_sp_HARV)
```

Our plot location extent is not the largest but is larger than the AOI
Boundary. It would be nice to see our vegetation plot locations plotted on top
of the Canopy Height Model information.

### In-class challenge 1: Crop to Vector Points Extent

1. Crop the Canopy Height Model to the extent of the study plot locations.
2. Plot the vegetation plot location points on top of the Canopy Height Model.


```{r}

```


**Solution**

```{r challenge-code-crop-raster-points}
CHM_plots_HARVcrop <- crop(x = CHM_HARV, y = plot_locations_sp_HARV)

CHM_plots_HARVcrop_df <- as.data.frame(CHM_plots_HARVcrop, xy = TRUE)

ggplot() +
  geom_raster(data = CHM_plots_HARVcrop_df,
              aes(x = x, y = y, fill = HARV_chmCrop)) +
  scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) +
  geom_sf(data = plot_locations_sp_HARV) +
  coord_sf()

```


In the plot above all the vegetation plot locations
(black dots) appear on the Canopy Height Model raster layer except for one. One
is situated on the blank space to the left of the map. Why?

A modification of the first figure in this demo is below, showing the
relative extents of all the spatial objects. Notice that the extent for our
vegetation plot layer (black) extends further west than the extent of our CHM
raster (bright green). The `crop()` function will make a raster extent smaller,
it will not expand the extent in areas where there are no data. Thus, the
extent of our vegetation plot layer will still extend further west than the
extent of our (cropped) raster data (dark green).

```{r, echo=FALSE}
# code not shown, demonstration only
# create CHM_plots_HARVcrop as a vector layer
CHM_plots_HARVcrop_sp <- st_as_sf(CHM_plots_HARVcrop_df, coords = c("x", "y"),
                                  crs = utm18nCRS)
# approximate the boundary box with random sample of raster points
CHM_plots_HARVcrop_sp_rand_sample = sample_n(CHM_plots_HARVcrop_sp, 10000)
```

**Define an Extent**

So far, we have used a vector layer to crop the extent of a raster dataset.
Alternatively, we can also the `ext()` function to define an extent to be
used as a cropping boundary. This creates a new object of class extent. Here we
will provide the `ext()` function our xmin, xmax, ymin, and ymax (in that
order).

```{r}
new_extent <- ext(732161.2, 732238.7, 4713249, 4713333)
class(new_extent)
```

**Function Tip**

The extent can be created from a numeric vector (as shown above), a matrix, or
a list. For more details see the `ext()` function help file
(`?terra::ext`).

Once we have defined our new extent, we can use the `crop()` function to crop
our raster to this extent object.

```{r crop-using-drawn-extent}
CHM_HARV_manual_cropped <- crop(x = CHM_HARV, y = new_extent)
```

To plot this data using `ggplot()` we need to convert it to a dataframe.

```{r}
CHM_HARV_manual_cropped_df <- as.data.frame(CHM_HARV_manual_cropped, xy = TRUE)
```

Now we can plot this cropped data. We will show the AOI boundary on the same
plot for scale.

```{r show-manual-crop-area}
ggplot() +
  geom_sf(data = aoi_boundary_HARV, color = "blue", fill = NA) +
  geom_raster(data = CHM_HARV_manual_cropped_df,
              aes(x = x, y = y, fill = HARV_chmCrop)) +
  scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) 
```

**Part 2: Extract Raster Pixels Values Using Vector Polygons**

Often we want to extract values from a raster layer for particular locations -
for example, plot locations that we are sampling on the ground. For example, we can extract
all pixel values within 20 m of our x,y point of interest. These can then be
summarized into some value of interest (e.g. mean, maximum, total).

![](fig//BufferSquare.png){alt='Image shows raster information extraction using 20m polygon boundary.'}
Image Source: National Ecological Observatory Network (NEON)

To do this in R, we use the `extract()` function. The `extract()` function
requires:

- The raster that we wish to extract values from,
- The vector layer containing the polygons that we wish to use as a boundary or
  boundaries,
- we can tell it to store the output values in a data frame using
  `raw = FALSE` (this is optional).

We will begin by extracting all canopy height pixel values located within our
`aoi_boundary_HARV` polygon which surrounds the tower located at the NEON
Harvard Forest field site.

```{r extract-from-raster}
tree_height <- extract(x = CHM_HARV, y = aoi_boundary_HARV, raw = FALSE)

str(tree_height)
```

When we use the `extract()` function, R extracts the value for each pixel
located within the boundary of the polygon being used to perform the extraction
- in this case the `aoi_boundary_HARV` object (a single polygon). Here, the
function extracted values from 18,450 pixels.

We can create a histogram of tree height values within the boundary to better
understand the structure or height distribution of trees at our site. We will
use the column `HARV_chmCrop` from our data frame as our x values, as this
column represents the tree heights for each pixel.

```{r view-extract-histogram}
ggplot() +
  geom_histogram(data = tree_height, aes(x = HARV_chmCrop)) +
  ggtitle("Histogram of CHM Height Values (m)") +
  xlab("Tree Height") +
  ylab("Frequency of Pixels")
```

We can also use the `summary()` function to view descriptive statistics
including min, max, and mean height values. These values help us better
understand vegetation at our field site.

```{r}
summary(tree_height$HARV_chmCrop)
```

**Summarize Extracted Raster Values**

We often want to extract summary values from a raster. We can tell R the type
of summary statistic we are interested in using the `fun =` argument. Let's
extract a mean height value for our AOI.

```{r summarize-extract}
mean_tree_height_AOI <- extract(x = CHM_HARV, y = aoi_boundary_HARV,
                                fun = mean)

mean_tree_height_AOI
```

It appears that the mean height value, extracted from our LiDAR data derived
canopy height model is 22.43 meters.

**Extract Data using x,y Locations**

We can also extract pixel values from a raster by defining a buffer or area
surrounding individual point locations using the `st_buffer()` function. To do
this we define the summary argument (`fun = mean`) and the buffer distance
(`dist = 20`) which represents the radius of a circular region around each
point. By default, the units of the buffer are the same units as the data's
CRS. All pixels that are touched by the buffer region are included in the
extract.

![](fig/BufferCircular.png){alt='Image shows raster information extraction using 20m buffer region.'}
Image Source: National Ecological Observatory Network (NEON)

Let's put this into practice by figuring out the mean tree height in the 20m
around the tower location (`point_HARV`).

```{r extract-point-to-buffer}
mean_tree_height_tower <- extract(x = CHM_HARV,
                                  y = st_buffer(point_HARV, dist = 20),
                                  fun = mean)

mean_tree_height_tower
```

### In class challenge 2: Extract Raster Height Values For Plot Locations

1) Use the plot locations object (`plot_locations_sp_HARV`) to extract an
  average tree height for the area within 20 m of each vegetation plot location
  in the study area. Because there are multiple plot locations, there will be
  multiple averages returned.

```{r}

```


2) Create a plot showing the mean tree height of each area.

```{r}

```


**Solution**

```{r hist-tree-height-veg-plot}
# extract data at each plot location
mean_tree_height_plots_HARV <- extract(x = CHM_HARV,
                                       y = st_buffer(plot_locations_sp_HARV,
                                                     dist = 20),
                                       fun = mean)

# view data
mean_tree_height_plots_HARV

# plot data
ggplot(data = mean_tree_height_plots_HARV, aes(ID, HARV_chmCrop)) +
  geom_col() +
  ggtitle("Mean Tree Height at each Plot") +
  xlab("Plot ID") +
  ylab("Tree Height (m)")
```
On Wednesday we will continue learning skills for vector-raster itegration. 

**Spatial Data in Text Format**

We would like to:

- Create a map of these plot locations, but we only have a .csv of their locations.
- Export the data in an ESRI `shapefile` format to share with our colleagues. This
  `shapefile` can be imported into most GIS software.
- Create a map showing vegetation height with plot locations layered on top.

Spatial data are sometimes stored in a text file format (`.txt` or `.csv`). If
the text file has an associated `x` and `y` location column, then we can
convert it into an `sf` spatial object. The `sf` object allows us to store both
the `x,y` values that represent the coordinate location of each point and the
associated attribute data - or columns describing each feature in the spatial
object.

**Import .csv**

The `HARV_PlotLocations.csv` file contains `x, y` (point) locations for study
plot where NEON collects data on
[vegetation and other ecological metics](https://www.neonscience.org/data-collection/terrestrial-organismal-sampling).

To begin let's import a `.csv` file that contains plot coordinate `x, y`
locations at the NEON Harvard Forest Field Site (`HARV_PlotLocations.csv`) and
look at the structure of that new object:

```{r read-csv}
plot_locations_HARV <-
  read.csv("data/NEON-DS-Site-Layout-Files/HARV/HARV_PlotLocations.csv")

str(plot_locations_HARV)
```

We now have a data frame that contains 21 locations (rows) and 16 variables
(attributes). Note that all of our character data was imported into R as
character (text) data. Next, let's explore the dataframe to determine whether
it contains columns with coordinate values. If we are lucky, our `.csv` will
contain columns labeled:

- "X" and "Y" OR
- Latitude and Longitude OR
- easting and northing (UTM coordinates)

Let's check out the column names of our dataframe.

```{r find-coordinates}
names(plot_locations_HARV)
```

**Identify X,Y Location Columns**

Our column names include several fields that might contain spatial information.
The `plot_locations_HARV$easting` and `plot_locations_HARV$northing` columns
contain coordinate values. We can confirm this by looking at the first six rows
of our data.

```{r check-out-coordinates}
head(plot_locations_HARV$easting)
head(plot_locations_HARV$northing)
```

We have coordinate values in our data frame. In order to convert our data frame
to an `sf` object, we also need to know the CRS associated with those
coordinate values.

There are several ways to figure out the CRS of spatial data in text format.

1. We can check the file metadata in hopes that the CRS was recorded in the
  data.
2. We can explore the file itself to see if CRS information is embedded in the
  file header or somewhere in the data columns.

Following the `easting` and `northing` columns, there is a `geodeticDa` and a
`utmZone` column. These appear to contain CRS information (`datum` and
`projection`). Let's view those next.

```{r view-CRS-info}
head(plot_locations_HARV$geodeticDa)
head(plot_locations_HARV$utmZone)
```

It is not typical to store CRS information in a column. But this particular
file contains CRS information this way. The `geodeticDa` and `utmZone` columns
contain the information that helps us determine the CRS:

- `geodeticDa`: WGS84  -- this is geodetic datum WGS84
- `utmZone`: 18

To create the `proj4` associated with UTM Zone 18 WGS84 we can look up the
projection on the
[Spatial Reference website](https://spatialreference.org/ref/epsg/32618/),
which contains a list of CRS formats for each projection. From here, we can
download the proj4 string for UTM Zone 18N WGS84 by clicking the proj link. 

However, if we have other data in the UTM Zone 18N projection, it's much easier
to use the `st_crs()` function to extract the CRS in `proj4` format from that
object and assign it to our new spatial object. We've seen this CRS before with
our Harvard Forest study site (`point_HARV`).

```{r explore-units}
st_crs(point_HARV)
```

The output above shows that the points vector layer is in UTM zone 18N. We can
thus use the CRS from that spatial object to convert our non-spatial dataframe
into an `sf` object.

Next, let's create a `crs` object that we can use to define the CRS of our `sf`
object when we create it.

```{r crs-object}
utm18nCRS <- st_crs(point_HARV)
utm18nCRS

class(utm18nCRS)
```

** .csv to sf object**

Next, let's convert our dataframe into an `sf` object. To do this, we need to
specify:

1. The columns containing X (`easting`) and Y (`northing`) coordinate values
2. The CRS that the column coordinate represent (units are included in the CRS) - stored in our `utmCRS` object.

We will use the `st_as_sf()` function to perform the conversion.

```{r convert-csv-shapefile}
plot_locations_sp_HARV <- st_as_sf(plot_locations_HARV,
                                   coords = c("easting", "northing"),
                                   crs = utm18nCRS)
```

We should double check the CRS to make sure it is correct.

```{r}
st_crs(plot_locations_sp_HARV)
```

**Plot Spatial Object**

We now have a spatial R object, we can plot our newly created spatial object.

```{r plot-data-points}
ggplot() +
  geom_sf(data = plot_locations_sp_HARV) +
  ggtitle("Map of Plot Locations")
```

### In class challenge 4: Import \& Plot Additional Points

We want to add two phenology plots to our existing map of vegetation plot
locations.

Import the .csv: `HARV/HARV_2NewPhenPlots.csv` into R and do the following:

1. Find the X and Y coordinate locations. Which value is X and which value is
   Y?
2. These data were collected in a geographic coordinate system (WGS84). Convert
  the dataframe into an `sf` object. HINT: check the crs of our other spatial objects to see if you can extract that crs to use to assign to the new data.
3. Plot the new points with the plot location points from above. Be sure to add
  a legend. Use a different symbol for the 2 new points!

If you have extra time, feel free to add roads and other layers to your map!

```{r}

```

**Solution**

1)
First we will read in the new csv file and look at the data structure.

```{r}
newplot_locations_HARV <-
  read.csv("data/NEON-DS-Site-Layout-Files/HARV/HARV_2NewPhenPlots.csv")
str(newplot_locations_HARV)
```

2)
The US boundary data we worked with previously is in a geographic WGS84 CRS. We
can use that data to establish a CRS for this data. First we will extract the
CRS from the `country_boundary_US` object and confirm that it is WGS84.

```{r}
geogCRS <- st_crs(country_boundary_US)
geogCRS
```

Then we will convert our new data to a spatial dataframe, using the `geogCRS`
object as our CRS.

```{r}
newPlot.Sp.HARV <- st_as_sf(newplot_locations_HARV,
                            coords = c("decimalLon", "decimalLat"),
                            crs = geogCRS)
```

Next we'll confirm that the CRS for our new object is correct.

```{r}
st_crs(newPlot.Sp.HARV)
```

We will be adding these new data points to the plot we created before. The data
for the earlier plot was in UTM. Since we're using `ggplot`, it will reproject
the data for us.

3) Now we can create our plot.

```{r plot-locations-harv-orange}
ggplot() +
  geom_sf(data = plot_locations_sp_HARV, color = "orange") +
  geom_sf(data = newPlot.Sp.HARV, color = "lightblue") +
  ggtitle("Map of All Plot Locations")
```


**Export to an ESRI `shapefile`**

We can write an R spatial object to an ESRI `shapefile` using the `st_write` function
in `sf`. To do this we need the following arguments:

- the name of the spatial object (`plot_locations_sp_HARV`)
- the directory where we want to save our ESRI `shapefile` (to use `current = getwd()`
  or you can specify a different path)
- the name of the new ESRI `shapefile` (`PlotLocations_HARV`)
- the driver which specifies the file format (ESRI Shapefile)

We can now export the spatial object as an ESRI `shapefile`.

```{r write-shapefile, warnings="hide", eval=FALSE}
st_write(plot_locations_sp_HARV,
         "data/PlotLocations_HARV.shp", driver = "ESRI Shapefile", append=FALSE)
```


```{r child="readings/08-reading.Rmd", echo=FALSE, error=TRUE}
```


```{r child="labs/08-lab-spatial2_student.Rmd", echo=FALSE, error=TRUE}
```


